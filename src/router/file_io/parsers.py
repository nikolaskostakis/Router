import re
from io import TextIOWrapper

from design_components import Design
from design_components import Row
from design_components import IOPort
from design_components import Component
from design_components import Net

HASH_LINE = "###############################################################"

#class PracticalFormatParser:
def practical_format_parcer(file:TextIOWrapper) -> Design:
    """A parser for files written based on the practical format"""

    # The states of the parser
    fileSections = ["Design Info", "Core Info", "Rows",
                    "IO Ports", "IO Ports CCs", "Components", "End"]
    design = None
    
    def _design_info_section(file:TextIOWrapper) -> Design:
        """Parses the section with design information"""

        # Hash Line
        line = file.readline().rstrip()
        if (line != HASH_LINE): return None

        # Generated by
        line = file.readline().rstrip()
        if not line.startswith("# Generated by: "): return None
        generatedBy = line

        # OS
        line = file.readline().rstrip()
        if not line.startswith("# OS: "): return None
        os = line

        # Generated on
        line = file.readline().rstrip()
        if not line.startswith("# Generated on: "): return None
        generatedOn = line

        line = file.readline().rstrip()
        splits = line.split(" ")
        if((len(splits) != 3) | (not line.startswith("# Design: "))):
            return None
        
        name = splits[2]
        comments = f"{generatedBy}\n{os}\n{generatedOn}"

        # Hash Line
        line = file.readline().rstrip()
        if (line != HASH_LINE): return None

        # Create new design
        design = Design(name, comments)

        return design
    # End of function

    def _core_info_section(file:TextIOWrapper) -> bool:
        """Parses the section with core information"""

        # Core Utilisation
        line = file.readline().rstrip()
        splits = re.split(" ", line)
        if((len(splits) != 4) | (not line.startswith("# Core Utilisation: "))):
            return False
        try:
            util = int(splits[3].replace('%',''))
        except ValueError:
            print("Utilisation is supposed to be: ##%%")
            return False
        except:
            print("File does not follow practical format syntax")
            return False

        # Core Width, Height & Aspect ratio
        line = file.readline().rstrip()
        splits = re.split(" ", line)
        if((len(splits) != 9) | (" Aspect Ratio: " not in line)
                | (not line.startswith("# Core Width, Height: "))):
            return False
        try:
            width = float(splits[4].replace(',',''))
            height = float(splits[5].replace(',',''))
            ratio = float(splits[8])
        except ValueError:
            print("Width, Height & Aspect Ratio are supposed to be " \
                  "floating-point numbers")
            return False
        except:
            print("File does not follow practical format syntax")
            return False
        
        # Core X, Y Offsets
        line = file.readline().rstrip()
        splits = re.split(" ", line)
        if((len(splits) != 7) | (not line.startswith("# Core X, Y Offsets: "))):
            return False
        try:
            xOffset = float(splits[5].replace(',',''))
            yOffset = float(splits[6])
        except ValueError:
            print("Offsets are supposed to be floating-point numbers")
            return False
        except:
            print("File does not follow practical format syntax")
            return False

        # Hash Line
        line = file.readline().rstrip()
        if (line != HASH_LINE): return False

        # Create the core of the design
        design.create_core(util, width, height, ratio, xOffset, yOffset)
        return True
    # End of function

    def _rows_section(file:TextIOWrapper) -> bool:
        """Parses the section with Rows"""

        # Rows
        line = file.readline().rstrip()
        if (line != "# Rows"): return False

        # Loop through the rows
        line = file.readline().rstrip()
        while True:
            # Check for hash line
            if (line == HASH_LINE): break

            splits = re.split(" ", line)
            if((len(splits) != 10) | (not line.startswith("Row: "))
                    | (" Type: " not in line) | (" Location: " not in line)
                    | (" Width/Height: " not in line)):
                return False
            
            name = splits[1]
            type = splits[3]
            try:
                xPos = float(splits[5])
                yPos = float(splits[6])
            except ValueError:
                print("Row coordinates are supposed to be " \
                      "floating-point numbers")
                return False
            except:
                print("File does not follow practical format syntax")
                return False
            try:
                width = float(splits[8])
                height = float(splits[9])
            except ValueError:
                print("Row dimentions are supposed to be " \
                      "floating-point numbers")
                return False
            except:
                print("File does not follow practical format syntax")
                return False
            
            # Create a new Row
            newRow = Row(name, type, xPos, yPos, width, height)
            # Store it in the design
            design.core.add_row(newRow)

            # Fetch next line
            line = file.readline().rstrip()
        
        return True
    # End of function

    def io_ports_section(file:TextIOWrapper) -> bool:
        """Parses the section with IO Ports"""

        # Top-Level I/O Ports
        line = file.readline().rstrip()
        if (line != "# Top-Level I/O Ports"): return False

        # Loop through the IO ports
        line = file.readline().rstrip()
        while True:
            # Check for hash line
            if (line == HASH_LINE): break

            splits = re.split(" ", line)
            if ((len(splits) != 5) | (not line.startswith("IO: "))
                    | (" Location: " not in line)):
                return False
            name = splits[1]
            try:
                xPos = float(splits[3])
                yPos = float(splits[4])
            except ValueError:
                print("IO Port coordinates are supposed to be " \
                      "floating-point numbers")
                return False
            except:
                print("File does not follow practical format syntax")
                return False

            sides = ["EAST", "WEST", "NORTH", "SOUTH"]
            line = file.readline().rstrip()
            splits = re.split(" ", line)
            if ((len(splits) != 3) | (splits[0] != "#") | (splits[2] != "SIDE")
                    | (splits[1] not in sides)):
                return False
            side = splits[1]

            # Create a new IO ports
            newIOPort = IOPort(name, xPos, yPos, side)
            # Store it in the design
            design.core.add_IO_port(newIOPort)

            # Fetch next line
            line = file.readline().rstrip()
        
        return True
    # End of function

    def _create_component(name:str) -> Component:
        """Searches if component exists in design and if not creates it"""
        # Check  if component exists
        newComponent: Component = design.core.get_component(name)
        if (not newComponent):
            # If component does not exist
            # Crate new component
            newComponent = Component(name)

            # Add new component to the design
            design.core.add_component(newComponent)

        return newComponent
    # End of function

    def _create_net(source, components) -> Net:
        """Creates a net from given source and components"""
        name = "N%d" % (design.core.noof_nets() + 1)
        newDrain = []
        for comp in components:
            # Add component to the list of endpoints of the net
            newComp = _create_component(comp)
            newDrain.append(newComp)
        
        # Add new net to the design
        return Net(name, source, newDrain)
    # End of function

    def io_ports_ccs_section(file:TextIOWrapper) -> bool:
        """Parses the section with the connections to the IO Ports"""

        # Top-Level I/O CCs
        line = file.readline().rstrip()
        if (line != "# Top-Level I/O CCs"): return False

        # Loop through the IO CCSs
        line = file.readline().rstrip()
        while True:
            # Check for hash line
            if (line == HASH_LINE): break

            splits = re.split(" ", line)
            if((len(splits) < 3) | (splits[0] != "IO:") | (splits[2] != "CCs:")):
                return False

            # If there are no connections to this port
            if (len(splits) == 3):
                line = file.readline().rstrip()
                continue

            # If there are connections to this port
            source = design.core.get_IO_port(splits[1])
            newNet = _create_net(source, splits[3:(len(splits) - 1)])
            design.core.add_net(newNet)

            # Fetch next line
            line = file.readline().rstrip()
        
        return True
    # End of function

    def components_section(file:TextIOWrapper) -> bool:
        """Parses the section with the components"""

        # Component CCs
        line = file.readline().rstrip()
        if (line != "# Component CCs"): return False

        # Loop through the components
        line = file.readline().rstrip()
        while True:
            if (not line):
                break
        
            splits = re.split(" ", line)
            name = splits[1]
            
            source = _create_component(name)
            newNet = _create_net(source, splits[3:(len(splits) - 1)])
            design.core.add_net(newNet)

            line = file.readline().rstrip()
        return True
    # End of function

    # Parse file 
    for state in fileSections:
        match state:
            case "Design Info":
                design = _design_info_section(file)
                if not design:
                    return None
            case "Core Info":
                if not _core_info_section(file):
                    break
            case "Rows":
                if not _rows_section(file):
                    break
            case "IO Ports":
                if not io_ports_section(file):
                    break
            case "IO Ports CCs": 
                if not io_ports_ccs_section(file):
                    break
            case "Components": 
                if not components_section(file):
                    break
            case "End":
                # Parsing was successful
                return design
    
    # Parsing was not successful
    del design
    return None
# End of function

def components_location_parser(file:TextIOWrapper, design: Design):
    """
    A parser for files containing the coordinates of components in a design
    """
    fileComponents: list[tuple] = []

    # Loop through the components and check if the 
    # components of the file exist in the design
    def extract_file_components() -> bool:
        """
        Extracts the components of the file and checks if they exist in the
        design
        """

        # Hash Line
        line = file.readline().rstrip()
        if (line != HASH_LINE): return False
        
        # Design
        line = file.readline().rstrip()
        splits =  re.split(" ", line)
        if ((len(splits) != 3) | (not line.startswith("# Design: "))):
            return False
        
        # Check if the design on the file is the same as the loaded design
        if (design.name != splits[2]):
            print("Stored file desing is not the same as the design loaded")
            return False

        # Hash Line
        line = file.readline().rstrip()
        if (line != HASH_LINE): return False

        # Components
        line = file.readline().rstrip()
        if (line != "# Components"): return False

        # Loop through the components
        line = file.readline().rstrip()
        while True:
            if (not line):
                break
        
            splits = re.split(" ", line)
            if ((len(splits) != 5) | (not line.startswith("Component: "))
                    | (" Location: " not in line)):
                return False
            name = splits[1]
            try:
                xPos = float(splits[3])
                yPos = float(splits[4])
            except ValueError:
                print("Component coordinates are supposed to be " \
                        "floating-point numbers")
                return False
            except:
                print("Something wrong has happened")
                return False
            
            # Check if component exists in the design
            if not design.core.get_component(name):
                print(f"Component {name} does not exist in the design")
                return False
            
            # Store it to the temporary list
            newComp = (name, xPos, yPos)
            fileComponents.append(newComp)
        
            # Fetch next line
            line = file.readline().rstrip()
        
        return True
    # End of function

    # Extract components form file
    if not extract_file_components():
        return False
    
    # See if extracted components are as many as those in the design
    # If they are not
    if (len(fileComponents) != design.core.noof_components()):
        # Failure
        print("Inconsistent number of components between file and design")
        return False
    
    # For every component int the design
    for fComp in fileComponents:
        # Update the coordinates
        comp = design.core.get_component(fComp[0])
        comp.x = fComp[1]
        comp.y = fComp[2]
    
    return True
# End of function